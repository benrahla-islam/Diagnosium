<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diagnosium - Chat Interface</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <!-- Add Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" 
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" 
    crossorigin=""/>
    <!-- Link to the new external CSS file -->
    <link rel="stylesheet" href="../static/chat.css">
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>
    <!-- Add Leaflet JS before your main.js -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" 
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" 
    crossorigin=""></script>
</head>
<body>
    <div id="app">
        <!-- Header -->
        <header>
            <div class="container">
                <div class="header-content">
                    <div class="logo">
                        <img src="../static/logo.png" alt="Diagnosium Logo"> <!-- Make sure this path is correct -->
                        Diagnosium
                    </div>
                    <nav>
                        <ul>
                            <li><a href="/">Home</a></li>
                            <li><a href="/chat">Chat</a></li>
                            <li><a href="/pricing">Pricing</a></li>
                            <li><a href="/about">About</a></li>
                        </ul>
                    </nav>
                    <!-- Assuming you have a sign-in button -->
                    <button class="sign-in-btn" @click="signIn">Sign In</button>
                </div>
            </div>
        </header>

        <!-- Main Content Area -->
        <div class="container main-content">

            <!-- Chat Interface -->
            <div class="chat-container">
                <div class="chat-header">
                    <div>Diagnosium Assistant</div>
                    <div class="status">[[ botStatus ]]</div>
                    <button class="patient-info-btn" @click="showPatientPopup = true">Patient Info</button>
                </div>

                <div class="chat-messages" ref="chatMessages">
                     <!-- Initial Welcome Message -->
                    <div v-if="messages.length === 0 && !isTyping" class="message bot-message initial-message">
                         <img src="../static/logo.png" alt="Bot" class="bot-avatar">
                         <div class="message-content">
                            How can I help you today? You can ask me about symptoms, find nearby facilities, or scan medication using the camera icon.
                         </div>
                    </div>

                    <!-- Chat Messages Loop -->
                    <div v-for="(message, index) in messages" :key="index"
                         :class="['message', message.sender === 'user' ? 'user-message' : 'bot-message']">
                        <img v-if="message.sender === 'bot'" src="../static/logo.png" alt="Bot" class="bot-avatar">
                        <div class="message-content">
                            <span v-html="message.text"></span> <!-- Use v-html if bot response might contain simple HTML like line breaks -->
                            <span class="timestamp">[[ message.time ]]</span>
                        </div>
                    </div>

                    <!-- Typing Indicator -->
                    <div v-if="isTyping" class="typing-indicator bot-message"> <!-- Added bot-message class for consistency -->
                        <img src="../static/logo.png" alt="Bot" class="bot-avatar">
                         <div class="message-content">
                            <span></span>
                            <span></span>
                            <span></span>
                         </div>
                    </div>
                </div>

                <!-- Chat Input Area -->
                <div class="chat-input">
                    <input
                        type="text"
                        v-model="userInput"
                        placeholder="Type your message or use the camera..."
                        @keyup.enter="sendMessage"
                        :disabled="isTyping || isAnalyzing"
                        ref="inputField"
                    >
                    <!-- Camera Button - Correctly placed here -->
                    <button class="camera-button" @click="openCamera" title="Scan Medication" :disabled="isTyping || isAnalyzing">
                        ðŸ“·
                    </button>
                    <button class="send-button" @click="sendMessage" :disabled="isTyping || !userInput.trim()">
                        âž¤
                    </button>
                </div>
            </div>

            <!-- Map Section -->
            <div class="map-section" v-show="showMap">
                <h2 style="margin-bottom: 15px; color: #3a7bd5; font-weight: 600;">Nearby Medical Facilities</h2>
                <div id="map-container"></div>
                <div class="info-box">
                    <h3 style="font-size: 14px; margin-bottom: 8px; font-weight: 600; color: #333;">Map Legend</h3>
                    <div class="legend">
                        <div class="legend-icon you-icon"></div>
                        <div>Your Location</div>
                    </div>
                    <div class="legend">
                        <div class="legend-icon pharmacy-icon"></div>
                        <div>Pharmacies</div>
                    </div>
                    <div class="legend">
                        <div class="legend-icon hospital-icon"></div>
                        <div>Hospitals/Clinics</div>
                    </div>
                    <div id="status">Loading map...</div>
                </div>
            </div>

        </div> <!-- End .main-content -->

        <!-- Patient Info Popup Modal -->
        <div v-if="showPatientPopup" class="modal-overlay" @click.self="showPatientPopup = false"> <!-- Close on overlay click -->
            <div class="modal-content">
                <h2>Patient Information</h2>
                <form @submit.prevent="submitPatientInfo">
                    <label>
                        Name:
                        <input type="text" v-model="patientInfo.name" required>
                    </label>
                    <label>
                        Age:
                        <input type="number" v-model.number="patientInfo.age" min="0" required> <!-- Use v-model.number -->
                    </label>
                    <label>
                        Gender:
                        <select v-model="patientInfo.gender" required>
                            <option disabled value="">Select Gender</option>
                            <option value="Male">Male</option>
                            <option value="Female">Female</option>
                            <option value="Other">Other</option>
                            <option value="Prefer not to say">Prefer not to say</option>
                        </select>
                    </label>
                    <label>
                        Known Allergies / Conditions:
                        <textarea v-model="patientInfo.symptoms" placeholder="e.g., Penicillin allergy, Diabetes Type 2"></textarea>
                    </label>
                    <div class="modal-actions">
                        <button type="submit">Save Info</button>
                        <button type="button" @click="showPatientPopup = false">Cancel</button>
                    </div>
                </form>
            </div>
        </div>

        <!-- Camera Modal - Correctly placed here -->
        <div v-if="showCameraModal" class="modal-overlay" @click.self="closeCamera"> <!-- Close on overlay click -->
            <div class="modal-content" style="max-width: 550px;"> <!-- Slightly wider modal for camera -->
                <h2>Scan Medication</h2>

                <!-- Show Loading Indicator OR Camera Preview/Captured Image -->
                <div v-if="isAnalyzing" class="analysis-indicator">
                    <div class="typing-indicator" style="align-self: center; background: none;">
                         <img src="../static/logo.png" alt="Bot" class="bot-avatar" style="margin-right: 0;">
                         <span></span><span></span><span></span>
                    </div>
                    <p>Analyzing medication, please wait...</p>
                </div>

                <div v-else> <!-- Show camera/preview only when not analyzing -->
                    <div class="camera-preview" v-show="!capturedImage"> <!-- Use v-show to keep video element in DOM -->
                        <video ref="video" autoplay playsinline muted style="width: 100%; border-radius: 8px;"></video> <!-- Added muted -->
                        <canvas ref="canvas" style="display: none;"></canvas>
                    </div>

                    <!-- Buttons below camera/preview -->
                     <div style="text-align: center; margin: 15px 0;">
                         <!-- Show Capture button only if no image is captured -->
                         <button v-if="!capturedImage" @click="captureImage" style="background: #3a7bd5; color: white; border: none; padding: 10px 20px; border-radius: 20px; cursor: pointer; font-size: 15px;">
                            Capture Image
                         </button>
                    </div>

                    <!-- Show captured image preview and actions -->
                    <div v-if="capturedImage" style="text-align: center;">
                        <p style="margin-bottom: 10px; font-size: 14px; color: #555;">Image Preview:</p>
                        <img :src="capturedImage" alt="Captured Medication" class="captured-image-preview">
                        <div class="modal-actions" style="justify-content: center;"> <!-- Center actions -->
                            <button type="button" @click="sendCapturedImage" style="background: #4CAF50;"> <!-- Green for Analyze -->
                                âœ” Analyze
                            </button>
                            <button type="button" @click="retakeImage">
                                â†º Retake
                            </button>
                            <button type="button" @click="closeCamera">
                                âœ– Cancel
                            </button>
                        </div>
                    </div>
                     <!-- Only show cancel button if no image captured yet -->
                     <div v-if="!capturedImage" class="modal-actions" style="justify-content: center;">
                           <button type="button" @click="closeCamera">Cancel</button>
                     </div>
                </div> <!-- End v-else (not analyzing) -->

            </div>
        </div>

        <!-- Footer -->
       <footer>
            <div class="container">
                <div class="footer-content">
                    <div class="footer-column">
                        <h3>Diagnosium</h3>
                        <ul>
                            <li><a href="/about">About Us</a></li>
                            <li><a href="#">Careers</a></li>
                            <li><a href="#">Press</a></li>
                        </ul>
                    </div>
                    <div class="footer-column">
                        <h3>Support</h3>
                        <ul>
                            <li><a href="#">Help Center</a></li>
                            <li><a href="#">Contact Us</a></li>
                            <li><a href="/privacy">Privacy Policy</a></li>
                            <li><a href="/terms">Terms of Service</a></li>
                        </ul>
                    </div>
                    <div class="footer-column">
                        <h3>Connect</h3>
                         <ul>
                            <li><a href="#">Facebook</a></li>
                            <li><a href="#">Twitter</a></li>
                            <li><a href="#">LinkedIn</a></li>
                        </ul>
                    </div>
                </div>
                <div class="copyright">
                    Â© 2023 Diagnosium. All rights reserved. This service is for informational purposes only and does not constitute medical advice.
                </div>
            </div>
        </footer>

    </div> <!-- End #app -->

    <!-- Include your main.js file -->
    <script src="../src/main.js"></script>
    <script>
        // Centralize API configuration - This should be before Vue initialization
        const API_BASE_URL = 'http://localhost:8000';
        
        // Vue app initialization
        new Vue({
            el: '#app',
            delimiters: ['[[', ']]'],
            data: {
                userInput: '',
                messages: [],
                isTyping: false,
                botStatus: 'Online',
                apiEndpoint: `${API_BASE_URL}/message`, // API for text chat
                showPatientPopup: false,
                showMap: false, // Control map visibility
                patientInfo: { // Keep patient info separate
                    name: '',
                    age: null, // Initialize age as null or 0
                    gender: '',
                    symptoms: '' // Renamed from 'symptoms' for clarity if needed, or keep as is. Maybe 'conditions_allergies'?
                },
                // Camera State - moved to top level
                showCameraModal: false,
                capturedImage: null, // Holds the base64 image data URL
                isAnalyzing: false, // Tracks if the image is being sent/processed
                stream: null       // Holds the MediaStream object
            },
            methods: {
                signIn() {
                    // Redirect to your login page or trigger a login modal
                    console.log("Sign In clicked");
                     window.location.href = "/login"; // Example redirect
                },
                sendMessage() {
                    const trimmedInput = this.userInput.trim();
                    if (!trimmedInput || this.isTyping || this.isAnalyzing) return;

                    const userMessage = {
                        text: trimmedInput,
                        sender: 'user',
                        time: this.getCurrentTime()
                    };
                    this.messages.push(userMessage);
                    this.scrollToBottom(); // Scroll after adding user message

                    const userQuestion = trimmedInput;
                    this.userInput = ''; // Clear input *after* capturing value

                    this.isTyping = true;
                    this.botStatus = 'Typing...';

                    this.getBotResponse(userQuestion);
                },

                async getBotResponse(question) {
                    const controller = new AbortController();
                    const signal = controller.signal;
                    const requestTimeout = 20000; // 20 seconds timeout

                    const timeoutId = setTimeout(() => {
                        controller.abort();
                        // No need to check isTyping here, the finally block handles it
                    }, requestTimeout);

                    const requestOptions = {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                             // Add any required Auth headers if needed, e.g.,
                             // 'Authorization': `Bearer ${your_jwt_token}`
                        },
                        // Send patient info context along with the message if available
                        body: JSON.stringify({
                             content: question,
                             patient_data: this.patientInfo // Send relevant patient data
                        }),
                        signal: signal
                    };

                    try {
                        const response = await fetch(this.apiEndpoint, requestOptions);
                        clearTimeout(timeoutId); // Clear timeout if response received

                        if (!response.ok) {
                            console.error('API Error Status:', response.status, response.statusText);
                            let errorMsg = `Sorry, there was a server error (${response.status}). Please try again later.`;
                            if (response.status === 429) {
                                errorMsg = "You've sent too many requests. Please wait a moment before trying again.";
                            } else {
                                // Attempt to read error message from response body
                                try {
                                     const errorData = await response.json();
                                     if(errorData && errorData.detail) {
                                         errorMsg = `Error: ${errorData.detail}`;
                                     }
                                } catch(e) { /* Ignore if body isn't JSON */ }
                            }
                             this.addBotMessage(errorMsg);
                        } else {
                            const data = await response.json();
                            if (data && typeof data.answer !== 'undefined') {
                                // Use the 'response' field from backend, fallback to diagnosis if missing
                                const botText = (data.answer.response || data.answer.diagnosis || '').replace(/\n/g, '<br>');
                                this.addBotMessage(botText);
                                this.showMap = true; // Use 'this.' to update Vue state
                            } else {
                                console.error('Invalid response structure:', data);
                                this.addBotMessage("I received an unexpected response from the server. Please try again.");
                            }
                        }
                    } catch (error) {
                        clearTimeout(timeoutId); // Clear timeout on error too
                        console.error('Fetch API Error:', error);

                        if (error.name === 'AbortError') {
                             this.addBotMessage("The request timed out as the server took too long to respond. Please try again.");
                        } else if (error instanceof TypeError) {
                             this.addBotMessage("Sorry, I couldn't connect to the server. Please check the API URL and ensure the server is running.");
                        }
                         else {
                            this.addBotMessage("An unexpected error occurred while trying to connect. Please check your network connection and try again.");
                        }
                    } finally {
                        // Always reset typing status, regardless of success or failure
                        this.isTyping = false;
                        this.botStatus = 'Online';
                         this.$nextTick(() => { // Ensure input is focusable after response/error
                            this.$refs.inputField.focus();
                         });
                    }
                },

                addBotMessage(text) {
                    const botMessage = {
                        text: text, // Text can now contain <br> tags
                        sender: 'bot',
                        time: this.getCurrentTime()
                    };
                    this.messages.push(botMessage);
                    this.scrollToBottom(); // Scroll after adding bot message
                },

                getCurrentTime() {
                    const now = new Date();
                    return now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: true }); // Use AM/PM
                },

                scrollToBottom() {
                    this.$nextTick(() => {
                        const chatContainer = this.$refs.chatMessages;
                        if (chatContainer) {
                             // Use smooth scroll for better UX
                            chatContainer.scrollTo({ top: chatContainer.scrollHeight, behavior: 'smooth' });
                        }
                    });
                },

                async submitPatientInfo() {
                     console.log("Submitting patient info:", this.patientInfo);
                    try {
                        // Optional: Send patient info to a specific endpoint if needed
                        // For now, we just save it locally and potentially send with chat messages
                         alert('Patient info updated locally!'); // Simple confirmation
                         // Example: Send to backend if needed
                        /*
                        const response = await fetch(`${API_BASE_URL}/patient-info`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(this.patientInfo)
                        });
                        if (!response.ok) {
                            alert('Failed to save patient info to server.');
                        } else {
                            alert('Patient info saved!');
                        }
                        */
                        this.showPatientPopup = false; // Close modal on success
                    } catch (e) {
                        console.error("Error submitting patient info:", e);
                        alert('An error occurred while saving patient info.');
                    }
                },

                // --- Camera Methods ---
                async openCamera() {
                    this.showCameraModal = true;
                    this.capturedImage = null; // Reset previous capture
                    this.isAnalyzing = false; // Reset analysis state

                    // Wait for the modal DOM to be ready
                    await this.$nextTick();

                    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                        this.addBotMessage("Camera access is not supported by your browser or device.");
                        this.closeCamera();
                        return;
                    }

                    try {
                        // Prioritize back camera ('environment')
                        this.stream = await navigator.mediaDevices.getUserMedia({
                            video: { facingMode: 'environment' }
                        });
                    } catch (err) {
                         console.warn("Could not get environment camera, trying default:", err);
                         try {
                            // Fallback to any available camera
                            this.stream = await navigator.mediaDevices.getUserMedia({ video: true });
                         } catch (finalErr) {
                            console.error("Camera access error:", finalErr);
                            let errorMsg = "Could not access the camera. ";
                            if (finalErr.name === 'NotAllowedError' || finalErr.name === 'PermissionDeniedError') {
                                errorMsg += "Please grant camera permissions in your browser settings.";
                            } else if (finalErr.name === 'NotFoundError' || finalErr.name === 'DevicesNotFoundError') {
                                 errorMsg += "No camera found on this device.";
                            } else {
                                 errorMsg += "An unexpected error occurred.";
                            }
                            this.addBotMessage(errorMsg);
                            this.closeCamera();
                            return; // Stop execution if camera fails
                         }
                    }

                    // If stream obtained successfully
                    if (this.stream && this.$refs.video) {
                        this.$refs.video.srcObject = this.stream;
                        this.$refs.video.play().catch(e => console.error("Video play error:", e)); // Handle autoplay issues
                    } else {
                         this.addBotMessage("Failed to initialize the camera view.");
                         this.closeCamera();
                    }
                },

                captureImage() {
                    const video = this.$refs.video;
                    const canvas = this.$refs.canvas;

                    if (!video || !canvas || !this.stream || video.readyState < video.HAVE_METADATA) {
                        console.error("Video stream not ready for capture.");
                        this.addBotMessage("Camera not ready, please try again.");
                        return;
                    }

                    // Set canvas dimensions based on the actual video dimensions
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;

                    // Draw the current video frame onto the canvas
                    const context = canvas.getContext('2d');
                    context.drawImage(video, 0, 0, canvas.width, canvas.height);

                    // Get the image data as JPEG (more common for photos)
                    try {
                         this.capturedImage = canvas.toDataURL('image/jpeg', 0.9); // 0.9 quality
                         console.log("Image captured, size:", Math.round(this.capturedImage.length * 3/4 / 1024), "KB");
                    } catch (e) {
                         console.error("Error converting canvas to data URL:", e);
                         this.addBotMessage("Failed to capture image properly.");
                         this.capturedImage = null;
                    }
                },

                retakeImage() {
                    this.capturedImage = null;
                    // Ensure video is playing if it was paused
                     if (this.$refs.video && this.$refs.video.paused) {
                         this.$refs.video.play().catch(e => console.error("Video play error:", e));
                     }
                },

                closeCamera() {
                    if (this.stream) {
                        this.stream.getTracks().forEach(track => track.stop());
                        this.stream = null;
                         // Also clear srcObject to remove the last frame in some browsers
                         if (this.$refs.video) {
                            this.$refs.video.srcObject = null;
                         }
                        console.log("Camera stream stopped.");
                    }
                    this.showCameraModal = false;
                    this.capturedImage = null;
                    this.isAnalyzing = false;
                },

                async sendCapturedImage() {
                    if (!this.capturedImage) return;

                    this.isAnalyzing = true; // Show loading indicator

                    try {
                        // Convert base64 image to blob
                        const fetchRes = await fetch(this.capturedImage);
                        const blob = await fetchRes.blob();

                        // Create form data to send to API
                        const formData = new FormData();
                        // Use a generic name, backend should handle it
                        formData.append('image', blob, 'medication_scan.jpg');

                        // Send to your medication analysis API endpoint
                        const response = await fetch(`${API_BASE_URL}/analyze-medication`, {
                            method: 'POST',
                            body: formData
                            // NO 'Content-Type' header here - browser sets it for FormData
                             // Add Auth headers if required by the API
                             // headers: { 'Authorization': `Bearer ${your_token}` }
                        });

                        // Add user message indicating image was sent
                        const userMsg = {
                            text: '(Sent medication image for analysis)',
                            sender: 'user',
                            time: this.getCurrentTime()
                        };
                        this.messages.push(userMsg);


                        if (!response.ok) {
                            console.error('Medication API Error Status:', response.status, response.statusText);
                            let errorMsg = `Analysis failed (${response.status}).`;
                             try {
                                 const errorData = await response.json();
                                 if(errorData && errorData.detail) { errorMsg += ` ${errorData.detail}`; }
                             } catch(e) { /* Ignore */ }
                            throw new Error(errorMsg); // Throw error to be caught below
                        }

                        const result = await response.json();
                        console.log("Analysis result:", result);

                        // Construct bot response based on API result
                        let botResponse = "I couldn't identify the medication from the image."; // Default
                        if (result && result.medicationName) {
                             botResponse = `Based on the image, this looks like: <strong>${result.medicationName}</strong>.`;
                            if(result.description) {
                                botResponse += `<br>${result.description}`;
                            }
                             if(result.warnings) {
                                botResponse += `<br><strong>Warnings:</strong> ${result.warnings}`;
                            }
                             // Add more fields as needed from your API response
                        } else if (result && result.message) {
                            // Handle cases where API returns a message instead of identification
                            botResponse = result.message;
                        }

                        this.addBotMessage(botResponse);

                    } catch (error) {
                        console.error("Error analyzing medication:", error);
                        this.addBotMessage(`Sorry, I encountered an error analyzing the medication image. ${error.message || 'Please try again.'}`);
                    } finally {
                        this.isAnalyzing = false;
                        this.closeCamera(); // Close modal after analysis (success or fail)
                    }
                }
            },
            watch: {
                 // Watch messages array changes to scroll down
                 messages: function() {
                    this.scrollToBottom();
                 }
            },
            mounted() {
                // Focus input field on component mount
                this.$nextTick(() => {
                    this.$refs.inputField.focus();
                    // Initialize the map after Vue has rendered the DOM
                    if (typeof initMap === "function") {
                        initMap();
                    }
                });
            },
            beforeDestroy() {
                // Ensure camera stream is stopped if component is destroyed
                this.closeCamera();
            }
        });
    </script>
</body>
</html>